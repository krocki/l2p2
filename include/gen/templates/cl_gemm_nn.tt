// http://www.cs.colostate.edu/~cs675/volkov08-sc08talk.pdf

// k_gen_ORDER_BLKSIZE_cl_gemm
__kernel void k_gen_M_$ORDER$_N_$ORDER$_K_$ORDER$_B_$BLKSZ$_W_$WX$_$WY$_cl_gemm_nn_(__global $T$* restrict C, const __global $T$* restrict A, const __global $T$* restrict B) {

	const int bx = get_group_id(0);
	const int tx = get_global_id(0);
	const int by = get_group_id(1);
	const int ty = get_global_id(1);
	const int gid = ty + $WY$ * $LY$ * tx;

	if (gid == 0) printf("gid %d A %d, B %d, C %d\n", gid, A, B, C);

	A += bx * 64 + tx + ty * 16;
	B += tx + (by * 16 + ty) * $ORDER$;
	C += bx * 64 + tx + (ty + by * $ORDER$) * 16;

	printf("gid %d, bx %d, by %d, tx %d, ty %d, A %d, B %d, C %d\n", gid, bx, by, tx, ty, A, B, C);

	__local $T$ bs[16][17];
	$T$ c[16];

	for (int i = 0; i < 16; i+= 4)
		bs[tx][ty+i] = B[i*$ORDER$];

	B += 16;
	barrier(CLK_LOCAL_MEM_FENCE);

	for (int i = 0; i < 16; i++, A += $ORDER$) {
		c[0] += A[0]*bs[i][0]; c[1] += A[0]*bs[i][1];
		c[2] += A[0]*bs[i][2]; c[3] += A[0]*bs[i][3];
		c[4] += A[0]*bs[i][4]; c[5] += A[0]*bs[i][5];
		c[6] += A[0]*bs[i][6]; c[7] += A[0]*bs[i][7];
		c[8] += A[0]*bs[i][8]; c[9] += A[0]*bs[i][9];
		c[10] += A[0]*bs[i][10];c[11] += A[0]*bs[i][11];
		c[12] += A[0]*bs[i][12];c[13] += A[0]*bs[i][13];
		c[14] += A[0]*bs[i][14];c[15] += A[0]*bs[i][15];
	}
	barrier(CLK_LOCAL_MEM_FENCE);

	for (int i = 0; i < 16; i++, C += $ORDER$)
		C[0] += c[i];
}

